---
title: "Rangified version of lexicographical_compare_three_way"
document: P2022R0
date: today
audience: 
    - LEWG
    - LWG
author:
    - name: Ran Regev
      email: <regev.ran@gmail.com>
toc: false
---   

# Motivation and Scope
This document adds the wording for ```ranges::lexicographical_compare_three_way``` 

# Proposed Wording 

## Add to [algorithm.syn]

> | template<class InputIterator1, class InputIterator2, class Cmp>
> |   constexpr auto
> |     lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
> |                                       InputIterator2 b2, InputIterator2 e2,
> |                                       Cmp comp)
> |       -> common_comparison_category_t<decltype(comp(\*b1, \*b2)), strong_ordering>;

> ::: add
> | template<
> |     input_iterator I1, sized_sentinel_for<I1> S1,
> |     input_iterator I2, sized_sentinel_for<I2> S2,
> |     class Proj1 = identity, 
> |     class Proj2 = identity,
> |     class Comp = compare_three_way
> | >
> | requires
> |     three_way_comparable_with< 
> |         projected<I1,Proj1>, projected<I2,Proj2> 
> |     >
> | constexpr auto
> |     ranges::lexicographical_compare_three_way( 
> |         I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 = {}, Proj2 = {}
> |     ) -> std::common_comparison_category_t<
> |                 decltype(comp(*first1, *first2)), std::strong_ordering>;
> :::

## Add to ยง25.7.11 [alg.three.way]

> | template<class InputIterator1, class InputIterator2, class Cmp>
> |   constexpr auto
> |     lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
> |                                       InputIterator2 b2, InputIterator2 e2,
> |                                       Cmp comp)
> |       -> common_comparison_category_t<decltype(comp(\*b1, \*b2)), strong_ordering>;

> ::: add
> | template<
> |     input_iterator I1, sentinel_for<I1> S1,
> |     input_iterator I2, sentinel_for<I2> S2,
> |     class Proj1 = identity, 
> |     class Proj2 = identity,
> |     class Comp = compare_three_way
> | >
> | requires
> |     three_way_comparable_with< 
> |         projected<I1,Proj1>, projected<I2,Proj2> 
> |     >
> | constexpr auto
> |     ranges::lexicographical_compare_three_way( 
> |         I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 = {}, Proj2 = {}
> |     ) -> std::common_comparison_category_t<
> |                 decltype(comp(*first1, *first2)), std::strong_ordering>;
> :::

> ::: add

1.
Let N be the minimum integer between distance(first1,s1) and distance(first2,s2).
Let E(n) be comp(proj1(*(first1 + n)), proj2(*(first2 + n))).

2.
Returns: E(i), where i is the smallest integer in [0, N) such that E(i) != 0 is true, or (distance(first1,s1) <=> distance(first2, s2) if no such integer exists.

3.
Complexity: At most N applications of comp.

> :::

> ::: add
> | template<
> |     input_range R1, input_range R2, 
> |     class Proj1 = identity, 
> |     class Proj2 = identity
> |     class Cat = partial_ordering,
> |     three_way_comparable_with<
> |         projected<iterator_t<R1>,Proj1>, projected<iterator_t<R2>,Proj2>, Cat
> |     > Comp = std::compare_three_way()
> | >
> | constexpr auto
> |     ranges::lexicographical_compare_three_way( 
> |         R1&& r1, R2&& r2, Comp comp = {}, Proj1 = {}, Proj2 = {}
> |     ) -> std::common_comparison_category_t<
> |                 decltype(comp(*r1.begin(), *r2.begin())), std::strong_ordering>;
> :::

> ::: add
- [2]{.pnum} _Mandates_: decltype(comp(\*r1.begin(), \*r2.begin())) is a comparison category type.
> :::


# Acknowledgements
    Dan Raviv <dan.raviv@gmail.com>
    Michael Park <mcpark@gmail.com> (for github.com/mpark/wg21)
